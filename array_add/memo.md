# あなたが書いたコードの問題点
1. **内側の `each_with_index` でインデックスを上書きしている**
   - 外側と内側で同じ変数名 `index` を使用しているため、意図した動作にならない。
2. **同じ要素を2回使う可能性がある**
   - `index1 == index2` のチェックがないため、同じ要素を足すケースを排除できていない。
3. **計算量が O(n²)**
   - 配列のすべてのペアを探索するため、配列のサイズが大きくなるとパフォーマンスが大きく低下する。
4. **結果として値を返している**
   - 問題文の要件に従うなら、値ではなくインデックスを返すべき。

# あなたが書いたコードの良い点
1. **基本的な構造は正しい**
   - 2つのループで配列内のすべてのペアを探索し、条件を満たすか確認する仕組みは正しい。
2. **コードが直感的**
   - 入れ子のループ構造は分かりやすく、初心者にも理解しやすい。

# ChatGPTが書いたコードの問題点
1. **コードがやや複雑に見える可能性**
   - ハッシュを利用する実装は、配列を直接操作する実装と比べると、初心者には少し難しく感じるかもしれない。
2. **ターゲットが2回出現するケースの扱い**
   - 要件によるが、同じ値が複数回出現する場合、どちらのインデックスを返すべきか明確でないケースがある。

# ChatGPTが書いたコードの良い点
1. **計算量が O(n)**
   - ハッシュを利用して探索することで、各要素を1回ずつ見るだけで済み、非常に効率的。
2. **同じ要素を使わない**
   - ハッシュを使った実装では同じ要素を2回使う問題が自然に排除される。
3. **コードが簡潔**
   - 冗長な条件チェックやループがなく、メモリ効率も良い。
4. **汎用性が高い**
   - この方法は、大きな配列や複雑な入力でも適用可能。

# 結論
あなたのコードは基本的なアプローチとしては良いですが、効率性や要件への適合性を考慮すると、ChatGPTのコードの方が優れています。

# chatgptの思考の流れ
## 1. 問題の理解
- **与えられた条件**:
  - 配列から2つの要素を選び、その合計が `target` に一致するペアを探す。
  - 結果として返すのはペアのインデックス。
  - **前提**: 解は必ず1つ存在し、同じ要素を2回使わない。
- **制約条件**:
  - 配列が大きくなる可能性があるため、効率的な計算が求められる。

---

## 2. 効率的なアプローチを検討
- **全探索（O(n²)）**:
  - 配列内のすべてのペアを調べる方法は直感的だが、非効率的。
- **最適化の可能性**:
  - ハッシュを利用すれば O(n) で解けることに気づく。

---

## 3. 差分に着目したアルゴリズム設計
- 合計が `target` に一致するためには、次の条件が必要:
  - `num1 + num2 = target`
  - つまり、`num2 = target - num1`
- **アルゴリズムのステップ**:
  1. 配列を1つずつ走査し、現在の値 `num` とその「差分」(`target - num`) を計算。
  2. 差分が既にハッシュに存在するか確認。
      - 存在する場合、差分のインデックスと現在のインデックスを返す。
  3. 存在しない場合、現在の値をハッシュに保存して次へ進む。

---

## 4. 実装
- ハッシュを利用して効率化。
- コードの簡潔さと可読性を重視。

### 実装コード
```ruby
def two_sum(numbers, target)
  seen = {}

  numbers.each_with_index do |num, index|
    complement = target - num

    if seen.key?(complement)
      return [seen[complement], index].sort
    end

    seen[num] = index
  end
end